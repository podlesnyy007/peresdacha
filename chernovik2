В текущем коде есть несколько ошибок, из-за которых результат не выводится в консоль, как ожидается. Давайте разберем проблемы и способы их исправления.

Ошибки в коде
Ошибка в методе Delete(ref Node t):

В этом методе есть строка if (t.Value == t.Value), которая всегда будет истинной. Судя по логике задачи, здесь должно быть условие для проверки, является ли узел нечетным, например: if (t.Value % 2 != 0).
Сейчас метод Delete(ref Node t) вызывает Delete(ref root, t.Value) для удаления значения, но так как оно выполняется внутри рекурсивного обхода, это приводит к неопределенному поведению и вызывает бесконечную рекурсию.
Рекурсивная структура метода удаления:

Методы удаления Delete(ref Node t) и Delete(ref Node t, int key) не работают должным образом вместе, так как основной метод удаления узла вызывается неверно.
Метод Delete(ref Node t) выполняет обход дерева и должен напрямую вызывать Delete(ref Node t, int key) только для нечетных значений узлов.
Исправленный код
Давайте исправим код с учетом вышеупомянутых ошибок.

csharp
Копировать код
using System;
using System.IO;

public class Node
{
    public int Value;
    public Node Left;
    public Node Right;

    public Node(int value)
    {
        Value = value;
        Left = null;
        Right = null;
    }
}

public class BinaryTree 
{
    public Node root;

    public void Insert(int value)
    {
        root = InsertRec(root, value);
    }

    private Node InsertRec(Node root, int value)
    {
        if (root == null)
        {
            root = new Node(value);
            return root;
        }

        if (value < root.Value)
        {
            root.Left = InsertRec(root.Left, value);
        }
        else if (value > root.Value)
        {
            root.Right = InsertRec(root.Right, value);
        }

        return root;
    }

    private static void Del(Node t, ref Node tr)
    {
        if (tr.Right != null)
        {
            Del(t, ref tr.Right);
        }
        else
        {
            t.Value = tr.Value;
            tr = tr.Left;
        }
    }
  
    // Метод, который удаляет узлы с нечетными значениями
    public void DeleteOddNodes(ref Node t)
    {
        if (t != null)
        {
            DeleteOddNodes(ref t.Left);
            DeleteOddNodes(ref t.Right);

            // Удаляем узел, если его значение нечетное
            if (t.Value % 2 != 0)
            {
                DeleteNode(ref t, t.Value);
            }
        }
    }

    private static void DeleteNode(ref Node t, int key)
    {
        if (t == null)
        {
            return;
        }

        if (key < t.Value)
        {
            DeleteNode(ref t.Left, key);
        }
        else if (key > t.Value)
        {
            DeleteNode(ref t.Right, key);
        }
        else
        {
            if (t.Left == null)
            {
                t = t.Right;
            }
            else if (t.Right == null)
            {
                t = t.Left;
            }
            else
            {
                Del(t, ref t.Left);
            }
        }
    }

    class Program
    {
        static void Main()
        {
            BinaryTree tree = new BinaryTree(); 

            // Чтение чисел из файла и добавление их в дерево
            string[] lines = File.ReadAllText("input.txt").Split(' ');
            foreach (string line in lines)
            {
                tree.Insert(int.Parse(line));
            }

            Console.WriteLine("Дерево до удаления нечетных узлов:");
            PrintInOrder(tree.root);
            Console.WriteLine();

            // Удаляем узлы с нечетными значениями
            tree.DeleteOddNodes(ref tree.root);

            Console.WriteLine("Дерево после удаления нечетных узлов:");
            PrintInOrder(tree.root);
        }

        static void PrintInOrder(Node node)
        {
            if (node != null)
            {
                PrintInOrder(node.Left);
                Console.Write(node.Value + " ");
                PrintInOrder(node.Right);
            }
        }
    }
}
Объяснение исправлений
Переименованный метод Delete на DeleteOddNodes:

Мы создали метод DeleteOddNodes, который обходит все узлы и удаляет те, у которых нечетное значение.
Вместо бесконечной рекурсии, метод корректно вызывает DeleteNode для каждого узла с нечетным значением.
Исправленная проверка на нечетное значение:

Теперь условие if (t.Value % 2 != 0) правильно проверяет, является ли значение узла нечетным, и, если да, вызывает DeleteNode для удаления этого узла.
Метод DeleteNode:

DeleteNode реализует логику удаления узла в бинарном дереве поиска, корректно перемещая дочерние узлы для сохранения структуры дерева.
С этими исправлениями код должен корректно выводить дерево до и после удаления нечетных узлов.
